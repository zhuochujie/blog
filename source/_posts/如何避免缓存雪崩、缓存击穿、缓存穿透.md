---
title: 如何避免缓存雪崩、缓存击穿、缓存穿透
date: 2025-07-11 21:01:31
tags: [缓存,系统设计]
---

在构建高性能、高并发的系统时，缓存是不可或缺的一环。它能有效减轻数据库的压力，提升应用的响应速度。然而，不当的缓存策略可能会引发一系列问题，其中最典型的就是缓存雪崩、缓存击穿和缓存穿透。本文将深入探讨这三个问题的成因，并提供切实可行的解决方案。

## 什么是缓存雪崩？

**缓存雪崩（Cache Avalanche）** 是指在短时间内，大量缓存键（Key）同时失效，或者缓存服务自身发生故障（如 Redis 宕机）。这导致海量的请求无法命中缓存，从而直接涌向数据库，给数据库带来巨大的压力，甚至可能导致数据库崩溃，进而引发整个系统的瘫痪。

其流程可描述为：正常情况下，大量请求访问缓存并命中；当缓存集体失效或服务宕机时，所有请求将直接穿透到数据库，导致数据库压力剧增。

### 成因分析

1.  **缓存同时过期**：在系统初始化时，我们可能会将大量数据一次性加载到缓存中，并设置了相同的过期时间。当到达这个过期时间点时，这些缓存会同时失效，导致请求全部转向数据库。
2.  **缓存服务故障**：缓存服务（如 Redis）所在的服务器发生故障或网络中断，导致缓存无法访问。

### 解决方案

1.  **过期时间随机化**：为避免缓存同时过期，可以在基础过期时间上增加一个随机值。例如，`expire_time = base_time + random(0, 3600)`，这样可以将过期时间分散开，避免在同一时刻集中失效。
2.  **设置热点数据永不过期**：对于一些访问非常频繁的热点数据（如首页内容、配置信息等），可以不设置过期时间，或者通过一个后台续期任务来定期更新缓存，避免其自然过期。
3.  **构建高可用的缓存集群**：使用 Redis Sentinel 或 Redis Cluster 等方案，构建高可用的缓存集群。当主节点发生故障时，可以自动进行主备切换，保证缓存服务的持续可用。
4.  **服务降级与限流**：在缓存失效或故障的情况下，为了保护后端的数据库，需要有应急预案。
    *   **服务降级**：可以暂时返回一个默认值、静态页面或者友好的提示，而不是直接去请求数据库。
    *   **限流**：通过 Nginx、Gateway 或应用层（如 Guava RateLimiter、Sentinel）来限制单位时间内的请求数量，避免所有请求都打到数据库上。

## 什么是缓存击穿？

**缓存击穿（Cache Breakdown）** 指的是某个访问极其频繁的热点 Key，在它失效的瞬间，恰好有大量的并发请求访问这个 Key。由于缓存中已无该数据，这些请求会同时穿透缓存，直接请求数据库，导致数据库压力瞬时增大。

缓存击穿和缓存雪崩的区别在于：击穿是针对**单个热点 Key**，而雪崩是针对**大量不同的 Key**。

其流程可描述为：大量并发请求访问同一个热点 Key，当该 Key 正好失效时，这些请求会同时穿透缓存，直接访问数据库。

### 成因分析

*   某个热点 Key 的过期时间到了。

### 解决方案

1.  **使用互斥锁（Mutex Lock）**：当缓存失效时，不立即去加载数据库，而是先使用一个互斥锁（如 Redis 的 `SETNX` 或 Redisson 分布式锁）。只允许第一个获取到锁的线程去查询数据库并回写缓存，其他线程则进行等待。当缓存被重新加载后，其他线程就可以直接从缓存中获取数据。
2.  **热点数据永不过期**：同缓存雪崩的解决方案类似，可以将热点数据的过期策略从“物理过期”改为“逻辑过期”。即不设置 `expire` 时间，而是在值的内部包含一个逻辑过期时间字段。当检测到数据逻辑过期时，由一个单独的线程去更新缓存。

## 什么是缓存穿透？

**缓存穿透（Cache Penetration）** 是指查询一个**根本不存在**的数据。由于缓存中没有，数据库中也没有，这就导致每次对这个 Key 的查询都会穿过缓存，直接打到数据库上。如果攻击者利用这个漏洞，构造大量不存在的 Key 进行恶意攻击，就会对数据库造成巨大压力。

其流程可描述为：请求查询一个不存在的 Key，缓存未命中，请求转向数据库，数据库也未找到，每次查询都重复此过程。

### 成因分析

1.  业务逻辑错误或代码缺陷，查询了不存在的数据。
2.  黑客恶意攻击，构造大量非法请求。

### 解决方案

1.  **缓存空对象（Cache Null Object）**：当数据库查询结果为空时，我们仍然将这个“空结果”缓存起来，但为其设置一个较短的过期时间（如 60 秒）。这样，后续对同一个不存在 Key 的查询会直接命中这个“空对象”，避免了对数据库的重复查询。
2.  **布隆过滤器（Bloom Filter）**：布隆过滤器是一种高效的数据结构，它可以用来判断一个元素是否可能存在于一个集合中。它的优点是空间效率和查询时间都远超一般的算法，缺点是有一定的误识别率（false positive，即可能将不存在的元素判断为存在）并且不支持删除操作。
    *   **使用方法**：将所有可能存在的数据哈希到一个足够大的位图中。当一个查询请求到来时，先在布隆过滤器中进行检查。如果过滤器判断该 Key 不存在，则直接返回；如果判断存在，再去查询缓存和数据库。这能有效拦截绝大部分对不存在 Key 的请求。
3.  **接口层参数校验**：在接口层对请求参数进行合法性校验。例如，用户 ID 是否为正整数、请求参数是否包含非法字符等。将不合法的请求在早期阶段就拦截掉。

## 总结

| 问题类型 | 描述 | 解决方案 |
| :--- | :--- | :--- |
| **缓存雪崩** | 大量 Key 同时失效或缓存服务宕机 | 1. 过期时间加随机值<br>2. 热点数据永不过期<br>3. 构建高可用缓存集群<br>4. 服务降级与限流 |
| **缓存击穿** | 单个热点 Key 失效，大量并发访问 | 1. 使用互斥锁<br>2. 热点数据永不过期 |
| **缓存穿透** | 查询不存在的数据，每次都打到数据库 | 1. 缓存空对象<br>2. 使用布隆过滤器<br>3. 接口参数校验 |

通过合理运用上述策略，我们可以大大提升缓存系统的健壮性和可靠性，从而为整个应用服务提供稳定、高效的支撑。